---
title: 正则表达式完全指南
date: 2026-01-23 14:30:00
categories:
  - 基础知识
  - 正则表达式
tags:
  - 正则表达式
  - 字符串处理
  - 面试
---

## 正则表达式基础

### 什么是正则表达式？

正则表达式（Regular Expression，简称 RegExp）是一种用于模式匹配和字符串操作的强大工具。它使用单个字符串来描述、匹配一系列符合某个语法规则的字符串。

### 为什么学习正则表达式？

- **文本验证**：验证邮箱、手机号、URL 等格式
- **数据提取**：从复杂文本中提取所需信息
- **文本替换**：批量替换符合规则的文本
- **日志分析**：快速定位和解析日志信息

---

## 基础语法

### 1. 字符匹配

| 符号 | 描述 | 示例 | 匹配结果 |
|------|------|------|----------|
| `.` | 匹配任意单个字符（除换行符） | `a.c` | abc, adc, aac |
| `[]` | 字符集，匹配其中任意一个字符 | `[abc]` | a, b, c |
| `[^]` | 否定字符集，匹配不在其中的字符 | `[^abc]` | d, e, f |
| `\d` | 匹配数字，等同于 `[0-9]` | `\d` | 0-9 |
| `\w` | 匹配字母、数字、下划线 | `\w` | a-z, A-Z, 0-9, _ |
| `\s` | 匹配空白字符（空格、制表符、换行符） | `\s` | 空格, \t, \n |

```javascript
// 示例
const text = "a1b c2d e3f";
console.log(text.match(/a.c/g));  // ["a1b"]
console.log(text.match(/\d/g));   // ["1", "2", "3"]
```

### 2. 量词

| 符号 | 描述 | 示例 | 匹配结果 |
|------|------|------|----------|
| `*` | 匹配 0 次或多次 | `a*` | "", a, aa, aaa |
| `+` | 匹配 1 次或多次 | `a+` | a, aa, aaa |
| `?` | 匹配 0 次或 1 次 | `a?` | "", a |
| `{n}` | 匹配恰好 n 次 | `a{3}` | aaa |
| `{n,}` | 匹配至少 n 次 | `a{2,}` | aa, aaa, aaaa |
| `{n,m}` | 匹配 n 到 m 次 | `a{2,4}` | aa, aaa, aaaa |

```javascript
// 示例
const text = "a aa aaa aaaa";
console.log(text.match(/a{2,3}/g));  // ["aa", "aaa", "aaa"]
```

### 3. 定位符

| 符号 | 描述 | 示例 | 匹配结果 |
|------|------|------|----------|
| `^` | 匹配字符串开头 | `^abc` | 以 abc 开头 |
| `$` | 匹配字符串结尾 | `abc$` | 以 abc 结尾 |
| `\b` | 匹配单词边界 | `\bword\b` | 独立的 word |
| `\B` | 匹配非单词边界 | `\Bword\B` | 单词内部的 word |

```javascript
// 示例
const text = "hello world, hello everyone";
console.log(text.match(/^hello/g));    // ["hello"] (只匹配开头的)
console.log(text.match(/hello$/g));    // null (不以 hello 结尾)
console.log(text.match(/\bhello\b/g)); // ["hello", "hello"]
```

### 4. 转义字符

如果要匹配特殊字符本身，需要使用反斜杠 `\` 转义：

```javascript
// 需要转义的特殊字符：. * + ? ^ $ { } [ ] ( ) | \ /
const url = "https://example.com";
console.log(url.match(/https?:\/\/\w+\.\w+/g)); // ["https://example.com"]
```

---

## 高级语法

### 1. 分组和引用

```javascript
// 捕获组 ()
const text = "2023-12-25";
const pattern = /(\d{4})-(\d{2})-(\d{2})/;
const match = text.match(pattern);
console.log(match[1]); // 2023 (年份)
console.log(match[2]); // 12   (月份)
console.log(match[3]); // 25   (日期)

// 非捕获组 (?:...)
const text2 = "abcabcabc";
console.log(text2.match(/(?:abc){2}/g)); // ["abcabc"]

// 反向引用 \1, \2...
const text3 = "hello hello";
console.log(text3.match(/(\w+) \1/g)); // ["hello hello"]
```

### 2. 选择符

```javascript
// 或运算 |
const text = "cat dog bat";
console.log(text.match(/cat|dog/g)); // ["cat", "dog"]

// 分组中使用选择符
const text2 = "call ball fall";
console.log(text2.match(/[cbf]all/g)); // ["call", "ball", "fall"]
```

### 3. 前瞻断言

```javascript
// 正向先行断言 (?=...)
const text = "apple1 banana2 cherry3";
console.log(text.match(/\w+(?=\d)/g)); // ["apple1", "banana2", "cherry3"]

// 负向先行断言 (?!...)
const text2 = "apple1 apple2 apple";
console.log(text2.match(/apple(?!\d)/g)); // ["apple"] (不匹配 apple1, apple2)

// 正向后行断言 (?<=...)
const text3 = "100px 200px 300em";
console.log(text3.match(/(?<=\d+)px/g)); // ["px", "px"]

// 负向后行断言 (?<!...)
const text4 = "100px 200em 300px";
console.log(text4.match(/(?<!\d+)em/g)); // ["em"]
```

---

## 常用正则表达式实例

### 1. 验证类

```javascript
// 邮箱验证
const emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
console.log(emailPattern.test("test@example.com")); // true

// 手机号验证（中国大陆）
const phonePattern = /^1[3-9]\d{9}$/;
console.log(phonePattern.test("13812345678")); // true

// 身份证号验证
const idCardPattern = /^[1-9]\d{5}(18|19|20)\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])\d{3}[\dXx]$/;
console.log(idCardPattern.test("110101199001011234")); // true

// URL 验证
const urlPattern = /^https?:\/\/[\w\-]+(\.[\w\-]+)+[/#?]?.*$/;
console.log(urlPattern.test("https://example.com/path?query=1")); // true

// IPv4 验证
const ipv4Pattern = /^((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$/;
console.log(ipv4Pattern.test("192.168.1.1")); // true

// 密码强度验证（至少8位，包含大小写字母和数字）
const passwordPattern = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]{8,}$/;
console.log(passwordPattern.test("Pass1234")); // true
```

### 2. 提取类

```javascript
// 提取所有数字
const text1 = "价格：¥199，折扣：8.5折，库存：1000件";
const numbers = text1.match(/\d+\.?\d*/g);
console.log(numbers); // ["199", "8.5", "1000"]

// 提取 HTML 标签内容
const html = "<div>Hello</div><span>World</span>";
const tags = html.match(/<(\w+)>(.*?)<\/\1>/g);
console.log(tags); // ["<div>Hello</div>", "<span>World</span>"]

// 提取日期
const text3 = "会议时间：2023-12-25，截止日期：2024-01-15";
const dates = text3.match(/\d{4}-\d{2}-\d{2}/g);
console.log(dates); // ["2023-12-25", "2024-01-15"]

// 提取图片 URL
const markdown = "![alt](https://example.com/image.png)";
const imgUrls = markdown.match(/!\[.*?\]\((.*?)\)/g);
console.log(imgUrls); // ["![alt](https://example.com/image.png)"]
```

### 3. 替换类

```javascript
// 移除所有空格
const text1 = "hello   world   test";
console.log(text1.replace(/\s+/g, "")); // "helloworldtest"

// 格式化电话号码
const phone = "13812345678";
console.log(phone.replace(/(\d{3})(\d{4})(\d{4})/, "$1-$2-$3")); // "138-1234-5678"

// 驼峰命名转换为短横线命名
const camelCase = "fontSize";
console.log(camelCase.replace(/([A-Z])/g, "-$1").toLowerCase()); // "font-size"

// 添加千位分隔符
const number = "1000000";
console.log(number.replace(/\B(?=(\d{3})+(?!\d))/g, ",")); // "1,000,000"

```

---

## JavaScript 中的正则表达式

### 1. 创建方式

```javascript
// 字面量方式（推荐）
const pattern1 = /abc/gi;

// 构造函数方式（动态创建）
const pattern2 = new RegExp("abc", "gi");

// 使用变量
const keyword = "hello";
const pattern3 = new RegExp(keyword, "g"); // 匹配 "hello"
```

### 2. 常用方法

```javascript
const text = "Hello World, Hello Everyone";
const pattern = /hello/gi;

// test() - 测试是否匹配
console.log(pattern.test(text)); // true

// exec() - 返回匹配详情
let match;
while ((match = pattern.exec(text)) !== null) {
  console.log(match[0], match.index);
  // "Hello" 0
  // "Hello" 13
}

// match() - 返回所有匹配
console.log(text.match(pattern)); // ["Hello", "Hello"]

// matchAll() - 返回所有匹配的迭代器
const matches = [...text.matchAll(pattern)];
console.log(matches.map(m => m[0])); // ["Hello", "Hello"]

// search() - 返回第一个匹配的位置
console.log(text.search(pattern)); // 0

// replace() - 替换匹配内容
console.log(text.replace(pattern, "Hi")); // "Hi World, Hi Everyone"

// replaceAll() - 替换所有匹配（字符串方法）
console.log(text.replaceAll("Hello", "Hi")); // "Hi World, Hi Everyone"

// split() - 按正则分割
console.log(text.split(/\s*,\s*/)); // ["Hello World", "Hello Everyone"]
```

### 3. 修饰符

| 修饰符 | 描述 | 示例 |
|--------|------|------|
| `g` | 全局匹配 | `/abc/g` |
| `i` | 不区分大小写 | `/abc/i` |
| `m` | 多行模式 | `/^abc/m` |
| `s` | 让 `.` 匹配换行符 | `/abc./s` |
| `u` | Unicode 模式 | `/abc/u` |
| `y` | 粘连匹配 | `/abc/y` |

```javascript
const text = "Hello\nworld";

// 没有 m 修饰符
console.log(text.match(/^w/)); // null

// 使用 m 修饰符（多行模式）
console.log(text.match(/^w/m)); // ["w"]

// 使用 s 修饰符（让 . 匹配换行符）
const text2 = "Hello\nworld";
console.log(text2.match(/Hello.world/s)); // ["Hello\nworld"]
```

---

## 实战案例

### 案例1：构建简单的模板引擎

```javascript
function renderTemplate(template, data) {
  return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
    return data[key] || "";
  });
}

const template = "Hello {{name}}, you are {{age}} years old.";
const data = { name: "Alice", age: 25 };
console.log(renderTemplate(template, data));
// "Hello Alice, you are 25 years old."
```

### 案例2：解析 URL 参数

```javascript
function parseQueryString(url) {
  const params = {};
  const pattern = /[?&]([^=#]+)=([^&#]*)/g;
  let match;

  while ((match = pattern.exec(url)) !== null) {
    params[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);
  }

  return params;
}

const url = "https://example.com?name=张三&age=25&city=北京";
console.log(parseQueryString(url));
// { name: "张三", age: "25", city: "北京" }
```

### 案例3：Markdown 解析器（简化版）

```javascript
function parseMarkdown(markdown) {
  let html = markdown;

  // 标题
  html = html.replace(/^### (.*$)/gim, "<h3>$1</h3>");
  html = html.replace(/^## (.*$)/gim, "<h2>$1</h2>");
  html = html.replace(/^# (.*$)/gim, "<h1>$1</h1>");

  // 粗体和斜体
  html = html.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/\*(.*?)\*/g, "<em>$1</em>");

  // 代码块
  html = html.replace(/```([\s\S]*?)```/g, "<pre><code>$1</code></pre>");
  html = html.replace(/`([^`]+)`/g, "<code>$1</code>");

  // 链接
  html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');

  return html;
}

const markdown = `# Hello World
This is a **bold** text and *italic* text.
[Link](https://example.com)`;

console.log(parseMarkdown(markdown));
```

### 案例4：表单验证器

```javascript
const validators = {
  required: (value) => value && value.trim() !== "",
  email: (value) => /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(value),
  phone: (value) => /^1[3-9]\d{9}$/.test(value),
  minLength: (value, min) => value.length >= min,
  maxLength: (value, max) => value.length <= max,
};

function validate(formData, rules) {
  const errors = {};

  for (const field in rules) {
    for (const rule of rules[field]) {
      const value = formData[field];

      if (rule.required && !validators.required(value)) {
        errors[field] = `${field} is required`;
        break;
      }

      if (rule.email && !validators.email(value)) {
        errors[field] = `${field} must be a valid email`;
        break;
      }

      if (rule.phone && !validators.phone(value)) {
        errors[field] = `${field} must be a valid phone number`;
        break;
      }

      if (rule.minLength && !validators.minLength(value, rule.minLength)) {
        errors[field] = `${field} must be at least ${rule.minLength} characters`;
        break;
      }

      if (rule.maxLength && !validators.maxLength(value, rule.maxLength)) {
        errors[field] = `${field} must be at most ${rule.maxLength} characters`;
        break;
      }
    }
  }

  return {
    isValid: Object.keys(errors).length === 0,
    errors,
  };
}

// 使用示例
const formData = {
  username: "john",
  email: "invalid-email",
  phone: "12345",
  password: "pass",
};

const rules = {
  username: [{ required: true, minLength: 3 }],
  email: [{ required: true, email: true }],
  phone: [{ phone: true }],
  password: [{ required: true, minLength: 8 }],
};

console.log(validate(formData, rules));
```

---

## 性能优化

### 1. 避免回溯灾难

```javascript
// ❌ 糟糕的模式（可能导致回溯灾难）
const badPattern = /^(a+)+$/;

// ✅ 更好的写法
const goodPattern = /^a+$/;

// ❌ 嵌套量词（危险）
const badPattern2 = /(a+)+b/;

// ✅ 展开或使用占有量词
const goodPattern2 = /a+b/;
```

### 2. 使用非捕获组

```javascript
// ❌ 使用捕获组（性能较低）
const pattern1 = /(\d{4})-(\d{2})-(\d{2})/;

// ✅ 使用非捕获组（性能更好）
const pattern2 = /(?:\d{4})-(?:\d{2})-(?:\d{2})/;
```

### 3. 避免过度使用 `.*`

```javascript
// ❌ 贪婪匹配（可能匹配过多内容）
const html = '<div>Content</div><div>More</div>';
const badMatch = html.match(/<div>.*<\/div>/);
console.log(badMatch[0]); // 匹配整个字符串（贪婪）

// ✅ 使用非贪婪匹配
const goodMatch = html.match(/<div>.*?<\/div>/);
console.log(goodMatch[0]); // 只匹配第一个 div

// ✅ 更精确的匹配
const betterMatch = html.match(/<div>[^<]*<\/div>/);
console.log(betterMatch[0]); // 最佳性能
```

### 4. 预编译正则表达式

```javascript
// ❌ 每次都重新创建
function validateEmail(email) {
  return /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(email);
}

// ✅ 预编译（性能更好）
const EMAIL_PATTERN = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;

function validateEmail(email) {
  return EMAIL_PATTERN.test(email);
}
```

---

## 调试技巧

### 1. 在线工具

- **Regex101**：https://regex101.com/（支持详细解释）
- **RegExr**：https://regexr.com/（交互式学习）
- **Debuggex**：https://www.debuggex.com/（可视化正则）

### 2. 测试方法

```javascript
// 使用 console.log 测试
const pattern = /\d{3}-\d{4}-\d{4}/;
const testCases = [
  "138-1234-5678",
  "123-456-789",
  "abc-def-ghij",
];

testCases.forEach(test => {
  console.log(test, "=>", pattern.test(test));
});

// 使用命名捕获组提高可读性
const datePattern = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
const match = datePattern.exec("2023-12-25");
console.log(match.groups); // { year: "2023", month: "12", day: "25" }
```

---

## 常见问题

### Q1：为什么我的正则不匹配换行符？

```javascript
const text = "Hello\nWorld";
console.log(text.match(/Hello.*World/)); // null

// 解决方案1：使用 [\s\S] 匹配任意字符（包括换行）
console.log(text.match(/Hello[\s\S]*World/)); // ["Hello\nWorld"]

// 解决方案2：使用 s 修饰符（ES2018）
console.log(text.match(/Hello.*World/s)); // ["Hello\nWorld"]
```

### Q2：如何匹配特殊字符？

```javascript
// 反斜杠转义
const pattern = /\$\d+\.\d{2}/; // 匹配价格 $19.99
console.log(pattern.test("$19.99")); // true

// 使用 RegExp 构造函数时需要双重转义
const pattern2 = new RegExp("\\$\\d+\\.\\d{2}");
```

### Q3：贪婪 vs 非贪婪

```javascript
const html = '<div>Short</div><div>Longer text</div>';

// 贪婪匹配（尽可能多）
console.log(html.match(/<div>.*<\/div>/)[0]);
// '<div>Short</div><div>Longer text</div>'

// 非贪婪匹配（尽可能少）
console.log(html.match(/<div>.*?<\/div>/)[0]);
// '<div>Short</div>'
```

---

## 总结

正则表达式是文本处理的瑞士军刀，掌握它可以：

1. **提高效率**：快速处理大量文本
2. **减少代码**：用简洁的模式表达复杂的匹配规则
3. **增强功能**：实现复杂的验证和解析功能

**学习建议**：
- 从简单的模式开始，逐步学习复杂语法
- 多练习，积累常用的正则表达式
- 使用在线工具辅助调试和理解
- 注意性能，避免回溯灾难

**参考资源**：
- [MDN - 正则表达式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)
- [JavaScript 正则表达式迷你书](https://github.com/ziyunfx/js-regexp-mini-book)
- [RegexOne - 交互式教程](https://regexone.com/)
