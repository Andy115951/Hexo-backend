# 250321oocl
1. 1.给一个非递减的数组和一个目标值，找到数组中这个目标值的起始位置和最终位置，没有返回[-1,-1]
2. 2.(departs l iname  ,emptoyeecount : 10,,d(name 't,emplopeeCount 20, deperts : arolname : b1', employeeCount : 5, departs : [(name : "b11',employeeCount : 6,)),Lbs(name : 'b2', smployeecount 10 l,(name 't', employeecount 30, depar name : 'ci' employeecount : 5 ,例师(rame 'c' employeecount : 20 ,(name : 'e' employeeCoum : 6 lll

给每个部门的其子部门的人数，例如a有10人，a的子部门a1有5，a2有5，那么a的部门人数有20人

3. 3.sql 查选了java或c++的人，选了java和c++的人，问平均分最高的人
4. 4.4.物流运费计算设计:某电商平台需根据用户选择的快递公司(顺丰、中通、邮政等)计算运费，不同快递公司的运费规则如下:

1)顺丰:首重15元(1kg内)，续重每公斤加8元2)中通:首重12元(1kg内)，续重每公斤加5元

3)邮政:首重10元(1kg内)，续重每公斤加3元

请使用合适的设计模式设计一个运费计算系统，以实现不同的快递公司的自动运费计算,同时方便增加其他新的快递公司的运费规则。



# 美团暑期一面
## 1.说一下你实习中的难点?
## 2.sql题:user表，有20个张三，40个李四，1个王五，找出没有重复的姓名
```sql
SELECT name
FROM user
GROUP BY name
HAVING COUNT(name) > 1;
```

## 3.让写出单例模式的双重检查式并解释为什么要做两次检查?
<font style="color:rgb(64, 64, 64);">双重检查锁定是一种在多线程环境下实现单例模式的优化方式。它通过两次检查来确保线程安全，同时避免每次调用 </font>`<font style="color:rgb(64, 64, 64);">getInstance()</font>`<font style="color:rgb(64, 64, 64);"> 时都进行同步锁的开销。</font>

```java
public class Singleton {
    // 使用 volatile 关键字确保 instance 的可见性和有序性
    private static volatile Singleton instance;

    // 私有构造函数，防止外部实例化
    private Singleton() {
    }

    // 双重检查锁定获取单例对象
    public static Singleton getInstance() {
        if (instance == null) { // 第一次检查
            synchronized (Singleton.class) { // 加锁
                if (instance == null) { // 第二次检查
                    instance = new Singleton(); // 创建实例
                }
            }
        }
        return instance;
    }
}
```

### <font style="color:rgb(64, 64, 64);">为什么要做两次检查？</font>
1. **<font style="color:rgb(64, 64, 64);">第一次检查（无锁）</font>**<font style="color:rgb(64, 64, 64);">：</font>
    - <font style="color:rgb(64, 64, 64);">目的是避免每次调用</font><font style="color:rgb(64, 64, 64);"> </font>`<font style="color:rgb(64, 64, 64);">getInstance()</font>`<font style="color:rgb(64, 64, 64);"> </font><font style="color:rgb(64, 64, 64);">时都进入同步块。</font>
    - <font style="color:rgb(64, 64, 64);">如果</font><font style="color:rgb(64, 64, 64);"> </font>`<font style="color:rgb(64, 64, 64);">instance</font>`<font style="color:rgb(64, 64, 64);"> </font><font style="color:rgb(64, 64, 64);">已经初始化，直接返回，无需加锁，提高性能。</font>
2. **<font style="color:rgb(64, 64, 64);">第二次检查（加锁）</font>**<font style="color:rgb(64, 64, 64);">：</font>
    - <font style="color:rgb(64, 64, 64);">目的是防止多个线程同时通过第一次检查后，重复创建实例。</font>
    - <font style="color:rgb(64, 64, 64);">在同步块内再次检查 </font>`<font style="color:rgb(64, 64, 64);">instance</font>`<font style="color:rgb(64, 64, 64);"> 是否为 </font>`<font style="color:rgb(64, 64, 64);">null</font>`<font style="color:rgb(64, 64, 64);">，确保只有一个线程能创建实例。</font>

### **<font style="color:rgb(64, 64, 64);">为什么需要</font>****<font style="color:rgb(64, 64, 64);"> </font>**`**<font style="color:rgb(64, 64, 64);">volatile</font>**`**<font style="color:rgb(64, 64, 64);"> </font>****<font style="color:rgb(64, 64, 64);">关键字？</font>**
`<font style="color:rgb(64, 64, 64);">volatile</font>`<font style="color:rgb(64, 64, 64);"> </font><font style="color:rgb(64, 64, 64);">关键字的作用：</font>

1. **<font style="color:rgb(64, 64, 64);">可见性</font>**<font style="color:rgb(64, 64, 64);">：确保</font><font style="color:rgb(64, 64, 64);"> </font>`<font style="color:rgb(64, 64, 64);">instance</font>`<font style="color:rgb(64, 64, 64);"> </font><font style="color:rgb(64, 64, 64);">的修改对所有线程立即可见。</font>
2. **<font style="color:rgb(64, 64, 64);">有序性</font>**<font style="color:rgb(64, 64, 64);">：防止指令重排序，避免在</font><font style="color:rgb(64, 64, 64);"> </font>`<font style="color:rgb(64, 64, 64);">instance</font>`<font style="color:rgb(64, 64, 64);"> </font><font style="color:rgb(64, 64, 64);">未完全初始化时被其他线程访问。</font>

<font style="color:rgb(64, 64, 64);">如果没有</font><font style="color:rgb(64, 64, 64);"> </font>`<font style="color:rgb(64, 64, 64);">volatile</font>`<font style="color:rgb(64, 64, 64);">，可能会发生以下情况：</font>

+ <font style="color:rgb(64, 64, 64);">线程 A 进入同步块，开始创建</font><font style="color:rgb(64, 64, 64);"> </font>`<font style="color:rgb(64, 64, 64);">Singleton</font>`<font style="color:rgb(64, 64, 64);"> </font><font style="color:rgb(64, 64, 64);">实例。</font>
+ <font style="color:rgb(64, 64, 64);">由于指令重排序，</font>`<font style="color:rgb(64, 64, 64);">instance</font>`<font style="color:rgb(64, 64, 64);"> </font><font style="color:rgb(64, 64, 64);">可能先被赋值，但对象还未完全初始化。</font>
+ <font style="color:rgb(64, 64, 64);">线程 B 在第一次检查时发现</font><font style="color:rgb(64, 64, 64);"> </font>`<font style="color:rgb(64, 64, 64);">instance</font>`<font style="color:rgb(64, 64, 64);"> </font><font style="color:rgb(64, 64, 64);">不为</font><font style="color:rgb(64, 64, 64);"> </font>`<font style="color:rgb(64, 64, 64);">null</font>`<font style="color:rgb(64, 64, 64);">，直接返回未完全初始化的对象。</font>

---

### **<font style="color:rgb(64, 64, 64);">双重检查锁定的优点</font>**
1. **<font style="color:rgb(64, 64, 64);">线程安全</font>**<font style="color:rgb(64, 64, 64);">：确保多线程环境下只创建一个实例。</font>
2. **<font style="color:rgb(64, 64, 64);">性能优化</font>**<font style="color:rgb(64, 64, 64);">：只有在第一次创建实例时才会加锁，后续调用无需加锁。</font>
3. **<font style="color:rgb(64, 64, 64);">延迟初始化</font>**<font style="color:rgb(64, 64, 64);">：实例在第一次使用时才创建，节省资源。</font>

<font style="color:rgb(64, 64, 64);"></font>

<font style="color:rgb(64, 64, 64);"></font>



## 4.说一下java的堆?什么时候会oom?
### <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">面试回答：Java 的堆和 OOM（Out of Memory）</font>
---

#### **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">1. Java 的堆是什么？</font>**
<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">Java 堆（Heap）是 JVM 内存管理中最大的一块区域，用于存放对象实例和数组。它是所有线程共享的内存区域，在 JVM 启动时创建，主要分为以下几个部分：</font>

+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">新生代（Young Generation）</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：存放新创建的对象，分为 Eden 区和两个 Survivor 区（S0 和 S1）。</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">老年代（Old Generation）</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：存放经过多次垃圾回收后仍然存活的对象。</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">元空间（Metaspace）</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：存放类的元数据信息（JDK 8 之前称为永久代 PermGen）。</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">堆的大小可以通过 JVM 参数设置，例如：</font>

+ `<font style="background-color:rgb(252, 252, 252);">-Xms</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：初始堆大小。</font>
+ `<font style="background-color:rgb(252, 252, 252);">-Xmx</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：最大堆大小。</font>

---

#### **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">2. 什么时候会发生 OOM？</font>**
<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">OOM（Out of Memory）是指 JVM 的堆内存不足以分配新对象时抛出的错误。常见场景包括：</font>

1. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">堆内存不足</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">对象数量过多，超出了堆的最大容量（</font>`<font style="background-color:rgb(252, 252, 252);">-Xmx</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"> </font><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">设置的值）。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">长时间运行的应用程序积累了大量的对象，导致堆内存耗尽。</font>
2. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">内存泄漏</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">对象被无意识地持有（如静态集合类缓存对象），导致无法被垃圾回收。</font>
3. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">大对象分配</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">创建了过大的对象（如大数组或大文件），超出了堆的可用空间。</font>
4. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">垃圾回收效率低</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">频繁的 Full GC 无法释放足够的内存，最终导致 OOM。</font>

---

#### **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">3. 如何分析和解决 OOM？</font>**
1. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">分析堆内存</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">使用工具（如 JVisualVM、MAT、JProfiler）分析堆转储文件（Heap Dump），找出内存泄漏的对象。</font>
2. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">优化代码</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">避免创建不必要的对象，及时释放资源。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">使用弱引用或软引用管理缓存。</font>
3. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">调整 JVM 参数</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">增加堆大小（</font>`<font style="background-color:rgb(252, 252, 252);">-Xmx</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">）。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">调整新生代和老年代的比例（</font>`<font style="background-color:rgb(252, 252, 252);">-XX:NewRatio</font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">）。</font>
4. **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">优化垃圾回收</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">选择合适的垃圾回收器（如 G1、ZGC）。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">调整 GC 参数以提高回收效率。</font>

---

#### **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">4. 示例回答</font>**
<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">“Java 的堆是 JVM 内存管理中最大的一块区域，用于存放对象实例和数组。它分为新生代、老年代和元空间。OOM 通常发生在堆内存不足、内存泄漏或大对象分配时。为了分析和解决 OOM，可以使用工具分析堆转储文件，优化代码避免内存泄漏，调整 JVM 参数增加堆大小，并选择合适的垃圾回收器。例如，在一次线上故障中，我发现 OOM 是由于静态集合类缓存了大量对象导致的，通过改用弱引用和增加堆大小解决了问题。”</font>

<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);"></font>

## 5.concurrenthashmap的put的过程?


## 6.说一下垃圾回收器?
## 7.G1垃圾回收器的参数有哪些?
## 8.mysql索引数据结构?
## 9.mysql事务隔离级别?默认的是哪个?
## 10.说一下 MVCC?
## 11.100个人抢10个商品，怎么保证不会超卖?
## 12.算法:删除有序链表中重复的节点




# <font style="color:rgb(51, 51, 51);">美团一面</font>
<font style="color:rgb(51, 51, 51);">项目10min，八股40min，闲聊10min</font>

<font style="color:rgb(51, 51, 51);">面试官介绍部门</font>

<font style="color:rgb(51, 51, 51);">自我介绍</font>

## <font style="color:rgb(51, 51, 51);">1.平常看了哪些技术书籍</font>
## <font style="color:rgb(51, 51, 51);">2.之前实习遇到的比较大的挑战，怎么解决的</font>
## <font style="color:rgb(51, 51, 51);">3.谈谈对java集合的理解</font>
## <font style="color:rgb(51, 51, 51);">4.ConcurrentHashMap的结构</font>
## <font style="color:rgb(51, 51, 51);">5.ConcurrentHashMap和HashMap吞吐量比较</font>
## <font style="color:rgb(51, 51, 51);">6.LinkedList和ArrayList的对比和分别的使用场景</font>
## <font style="color:rgb(51, 51, 51);">7.了解AQS吗</font>
## <font style="color:rgb(51, 51, 51);">8.深拷贝浅拷贝</font>
## <font style="color:rgb(51, 51, 51);">9.Spring AOP的实现方式</font>
## <font style="color:rgb(51, 51, 51);">10.AOP、过滤器、拦截器区别</font>
## <font style="color:rgb(51, 51, 51);">11.Kafka与RabbitMQ对比</font>
## <font style="color:rgb(51, 51, 51);">12.Kafka能手动删除消息吗</font>
## <font style="color:rgb(51, 51, 51);">13.讲下Kafka消费者组</font>
## <font style="color:rgb(51, 51, 51);">14.SpringBoot核心注解</font>
## <font style="color:rgb(51, 51, 51);">15.线程池实现原理</font>
## <font style="color:rgb(51, 51, 51);">16.线程池四种拒绝策略</font>
## <font style="color:rgb(51, 51, 51);">17.线程有哪些状态</font>
<font style="color:rgb(51, 51, 51);">面试官再次介绍部门</font>

<font style="color:rgb(51, 51, 51);">反问</font>

# <font style="color:rgb(51, 51, 51);">美团二面</font>
<font style="color:rgb(51, 51, 51);">实习15min 手撕10min 闲聊5min</font>

## <font style="color:rgb(51, 51, 51);">1.之前为什么离职</font>
## <font style="color:rgb(51, 51, 51);">2.讲一个实习中印象最深刻的bug</font>
## <font style="color:rgb(51, 51, 51);">3.其它一些实习相关的东西...</font>
## <font style="color:rgb(51, 51, 51);">4.手撕：三数之和+反转链表</font>
## <font style="color:rgb(51, 51, 51);">5.闲聊。多久能到岗之类的</font>
## <font style="color:rgb(51, 51, 51);">6.反问</font>


# 新大陆面试
## <font style="color:rgb(51, 51, 51);">介绍一下项目的背景、业务</font>
## <font style="color:rgb(51, 51, 51);">ThreadLocal原理，能做什么事情</font>
## <font style="color:rgb(51, 51, 51);">Java常用集合类</font>
## <font style="color:rgb(51, 51, 51);">有一个集合，有1000条影视记录，有一个评分字段，我想根据评分保存评分最高的30条，应该用什么集合存放，怎么实现</font>
## <font style="color:rgb(51, 51, 51);">线程池的扩容流程</font>
## <font style="color:rgb(51, 51, 51);">CAS的原理是什么，有什么缺点或优点</font>
## <font style="color:rgb(51, 51, 51);">讲一下垃圾回收机制</font>
## <font style="color:rgb(51, 51, 51);">Redis持久化有哪两种方式，两者的优缺点</font>
## <font style="color:rgb(51, 51, 51);">一次循环反转一条单链表</font>
## <font style="color:rgb(51, 51, 51);">二叉树层次遍历，需要用到哪种数据结构</font>
## <font style="color:rgb(51, 51, 51);">怎么判断一个有向图里面有没有环</font>
## <font style="color:rgb(51, 51, 51);">前端了解吗，html, css, js, vue这些</font>
## <font style="color:rgb(51, 51, 51);">docker用过吗</font>
## <font style="color:rgb(51, 51, 51);">如何进入一个docker 容器，命令是啥</font>
## <font style="color:rgb(51, 51, 51);">把容器的文件映射到物理主机，用的是哪个参数</font>
## <font style="color:rgb(51, 51, 51);">mysql怎么看sql有没有走索引</font>
## <font style="color:rgb(51, 51, 51);">你觉得用的表较多的存储引擎是哪个</font>


# <font style="color:rgb(51, 51, 51);">佰均成</font>
## <font style="color:rgb(51, 51, 51);">java的io流你知道吗</font>
## <font style="color:rgb(51, 51, 51);">java的类锁你知道吗</font>
## <font style="color:rgb(51, 51, 51);">你能说一下synchronized的原理吗</font>
## <font style="color:rgb(51, 51, 51);">分布式锁知道吗，它跟普通锁有什么区别</font>
## <font style="color:rgb(51, 51, 51);">使用数据库怎么做分布式锁，你会怎么设计</font>
## <font style="color:rgb(51, 51, 51);">红黑树你能介绍一下吗</font>
## <font style="color:rgb(51, 51, 51);">你对分布式CAP理论里面的高可用性是怎么理解</font>
## <font style="color:rgb(51, 51, 51);">你对中间件这块了解吗</font>
## <font style="color:rgb(51, 51, 51);">RabbitMQ怎么保证数据不丢失</font>
## <font style="color:rgb(51, 51, 51);">你对接口的幂等性是怎么理解的呢</font>
<font style="color:rgb(51, 51, 51);">闭上眼睛回答问题...</font>

## <font style="color:rgb(51, 51, 51);">线程状态的流转流程</font>
## <font style="color:rgb(51, 51, 51);">wait和sleep有什么区别</font>
## <font style="color:rgb(51, 51, 51);">b+树和b树的区别</font>


# <font style="color:rgb(51, 51, 51);">哈啰日常实习一面</font>
## <font style="color:rgb(51, 51, 51);">自我介绍</font>
## <font style="color:rgb(51, 51, 51);">JMM 是什么</font>


## <font style="color:rgb(51, 51, 51);">Synchronized 和 ReentranLock 区别</font>
## <font style="color:rgb(51, 51, 51);">DI 是怎么理解的</font>
## <font style="color:rgb(51, 51, 51);">Spring 是怎么管理 Bean</font>
## <font style="color:rgb(51, 51, 51);">Spring 的循环依赖</font>
## <font style="color:rgb(51, 51, 51);">HashMap ConcurrentHashMap 原理</font>
## <font style="color:rgb(51, 51, 51);">HashMap 为什么线程不安全</font>
## <font style="color:rgb(51, 51, 51);">Java 中的锁</font>






<font style="color:rgb(51, 51, 51);"></font>



