---
title: 动态代理
date: 2025-03-04 21:35:52
categories:
  - 设计模式
  - 动态代理
tags:
---

**动态代理实现**

### <font style="color:rgb(79, 79, 79);">jdk动态代理</font>
#### <font style="color:rgb(79, 79, 79);">基于接口实现代理</font>
<font style="color:rgb(77, 77, 77);">使用java反射包中的接口和类实现动态代理，要求代理类和工具类实现同一个接口。  
</font><font style="color:rgb(77, 77, 77);">其中反射包是java.lang,reflect，里面有三个类：InvocationHandler、Method、Proxy</font>

#### <font style="color:rgb(79, 79, 79);">3.1 创建目标接口</font>
```java
public interface Star {
    String sing(String name);
    void dance();
}

```

#### <font style="color:rgb(79, 79, 79);">3.2 创建目标类实现目标接口</font>
```java
public class BigStar implements Star {
    private String name;

    public BigStar(String name) {
        this.name = name;
    }

    public String sing(String name) {
        System.out.println(this.name + "正在唱歌儿:" + name);
        return "谢谢儿!谢谢儿!";
    }

    public void dance() {
        System.out.println(this.name + "正在跳舞儿");
    }
}


```

#### <font style="color:rgb(79, 79, 79);">3.3 创建代理工具</font>
```java
public class ProxyUtil {
    public static Star createProxy(BigStar bigStar) {
        /*newProxyInstance(ClassLoader loader,
                Class<?>[] interfaces,
                InvocationHandler h)
                参数1:用于指定一个类加载器
                参数2:指定生成的代理长什么样子，也就是有哪些方法
                参数3:用来指定生成的代理对象要干什么事情
                */
        // Star starProxy = ProxyUtil.createProxy(s);
        // starProxy.sing("好日子") starProxy.dance()
        Star starProxy = (Star) Proxy.newProxyInstance(ProxyUtil.class.getClassLoader(),
                                                       new Class[]{Star.class},
                                                       new InvocationHandler() {
                                                           @Override //回调方法：当主程序执行sing方法时会调用invoke，并将参数传过来
                                                           // proxy就是代理对象starProxy,method指sing,args指"好日子"
                                                           public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                                                               //代理对象要做的事情，会在这里写代码
                                                               if (method.getName().equals("sing")) {
                                                                   System.out.println("准备话筒，收钱20万");
                                                               } else if (method.getName().equals("dance")) {
                                                                   System.out.println("准备场地，收钱1000万");
                                                               }
                                                               return method.invoke(bigStar, args);
                                                           }
                                                       });
        return starProxy;
    }
}
```

#### <font style="color:rgb(79, 79, 79);">3.4 测试调用</font>
```java
public class Test {
    public static void main(String[] args) {
        BigStar s = new BigStar("杨超越");
        Star starProxy = ProxyUtil.createProxy(s);
        String rs = starProxy.sing("好日子");
        System.out.println(rs);
        starProxy.dance();
    }
}

```

#### <font style="color:rgb(79, 79, 79);">3.5 运行结果：</font>
![](https://cdn.nlark.com/yuque/0/2025/png/38820023/1742800771406-b5418e0e-1aac-4fe3-a954-d659940c2edf.png)

#### <font style="color:rgb(79, 79, 79);">3.6 执行逻辑：</font>
![](https://cdn.nlark.com/yuque/0/2025/png/38820023/1742800771399-4a4389d8-2ecf-47d8-a277-3fe5d0e56e32.png)<font style="color:rgb(77, 77, 77);">  
</font>![](https://cdn.nlark.com/yuque/0/2025/png/38820023/1742800771445-f4d8c9f6-b697-455f-9b9b-acbe49ff2938.png)

<font style="color:rgb(77, 77, 77);">当主程序调用sing方法时，会调用invoke方法，因为代理干什么事情由代理决定。此时invoke方法里的proxy代表starProxy，method代表sing方法，args代表sing方法中的参数。因为是sing方法符合if里面的条件输出内容，然后执行return method.invoke(bigStar,args)。因为传进来是BigStar对象所以执行BigStar对象中的sing方法，输出内容返回返回值，主程序输出返回的结果。  
</font><font style="color:rgb(77, 77, 77);">执行dance方法同理。</font>

## <font style="color:rgb(79, 79, 79);">四、案例-使用代理优化用户管理类</font>
<font style="color:rgb(77, 77, 77);">场景</font>

+ <font style="color:rgba(0, 0, 0, 0.75);">某系统有一一个用户管理类,包含用户登录,删除用户，查询用户等功能，系统要求统  
</font><font style="color:rgba(0, 0, 0, 0.75);">计每个功能的执行耗时情况，以便后期观察程序性能。</font>

<font style="color:rgb(77, 77, 77);">需求</font>

+ <font style="color:rgba(0, 0, 0, 0.75);">现在,某个初级程序员已经开发好了该模块，请观察该模块的代码,找出目前存在的  
</font><font style="color:rgba(0, 0, 0, 0.75);">问题，并对其进行改造。</font>

```java
/**
 * 用户业务接口
 */
public interface UserService {
    //登录功能
    void login(String loginName, String passWord) throws InterruptedException;

    //删除用户
    void deleteUsers() throws InterruptedException;

    //查询用户，返回数组的形式
    String[] selectUsers() throws InterruptedException;
}

```

```java
/**
 * 用户业务实现类（面向接口编程）
 */
public class UserServiceImpl implements UserService {
    @Override
    public void login(String loginName, String passWord) throws InterruptedException {
        long startTime = System.currentTimeMillis();
        if ("admin".equals(loginName) && "123456".equals(passWord)) {
            System.out.println("您登录成功，欢迎光临本系统~");
        } else {
            System.out.println("您登录失败，用户名或密码错误~");
        }
        Thread.sleep(1000);
        long endTime = System.currentTimeMillis();
        System.out.println("login方法执行耗时：" + (endTime - startTime) / 1000.0 + "s");
    }

    @Override
    public void deleteUsers() throws InterruptedException {
        long startTime = System.currentTimeMillis();
        System.out.println("成功删除了1万个用户");
        Thread.sleep(1500);
        long endTime = System.currentTimeMillis();
        System.out.println("deleteUsers方法执行耗时：" + (endTime - startTime) / 1000.0 + "s");
    }

    @Override
    public String[] selectUsers() throws InterruptedException {
        long startTime = System.currentTimeMillis();
        System.out.println("查询出了3个用户");
        String[] names = {"金庸", "莫言", "南派三叔"};
        Thread.sleep(500);
        long endTime = System.currentTimeMillis();
        System.out.println("selectUsers方法执行耗时：" + (endTime - startTime) / 1000.0 + "s");
        return names;
    }
}


```

```java
/**
 * 目标: 使用动态代理解决实际问题，并掌握使用代理的好处。
 */
public class Test {
    public static void main(String[] args) throws Exception {
        //1、创建用户业务对象
        UserService userService = new UserServiceImpl();
        //2、调用用户业务的功能
        userService.login("admin", "123456");
        System.out.println("--------------------------------------");
        userService.deleteUsers();
        System.out.println("--------------------------------------");
        String[] names = userService.selectUsers();
        System.out.println("查询到的用户是：" + names);
        System.out.println("--------------------------------------");

    }
}



```

<font style="color:rgb(77, 77, 77);">测试结果：  
</font>![](https://cdn.nlark.com/yuque/0/2025/png/38820023/1742800771695-9157a5cb-66b2-48cc-9541-df313ed32143.png)

```java
public class ProxyUtil {
    public static UserService createProxy(UserService userService) {
        /*newProxyInstance(ClassLoader loader,
                Class<?>[] interfaces,
                InvocationHandler h)
                参数1:用于指定一个类加载器
                参数2:指定生成的代理长什么样子，也就是有哪些方法
                参数3:用来指定生成的代理对象要干什么事情
                */
        // Star starProxy = ProxyUtil.createProxy(s);
        // starProxy.sing("好日子") starProxy.dance()
        UserService userServiceProxy = (UserService) Proxy.newProxyInstance(ProxyUtil.class.getClassLoader(),
                                                                            new Class[]{UserService.class},
                                                                            new InvocationHandler() {
                                                                                @Override
                                                                                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                                                                                    //代理对象要做的事情，会在这里写代码
                                                                                    if (method.getName().equals("login") || method.getName().equals("deleteUsers") ||
                                                                                        method.getName().equals("selectUsers")) {
                                                                                        long startTime = System.currentTimeMillis();
                                                                                        Object rs = method.invoke(userService, args);
                                                                                        long endTime = System.currentTimeMillis();
                                                                                        System.out.println(method.getName() + "方法执行耗时：" + (endTime - startTime) / 1000.0 + "s");
                                                                                        return rs;
                                                                                    } else {
                                                                                        Object rs = method.invoke(userService, args);
                                                                                        return rs;
                                                                                    }
                                                                                }
                                                                            });
        return userServiceProxy;
    }
}
```

<font style="color:rgb(77, 77, 77);">修改UserServiceImpl</font>

```java
/**
 * 用户业务实现类（面向接口编程）
 */
public class UserServiceImpl implements UserService {
    @Override
    public void login(String loginName, String passWord) throws InterruptedException {
        if ("admin".equals(loginName) && "123456".equals(passWord)) {
            System.out.println("您登录成功，欢迎光临本系统~");
        } else {
            System.out.println("您登录失败，用户名或密码错误~");
        }
        Thread.sleep(1000);
    }

    @Override
    public void deleteUsers() throws InterruptedException {
        System.out.println("成功删除了1万个用户");
    }

    @Override
    public String[] selectUsers() throws InterruptedException {
        System.out.println("查询出了3个用户");
        String[] names = {"金庸", "莫言", "南派三叔"};
        Thread.sleep(500);
        return names;
    }
}


```

<font style="color:rgb(77, 77, 77);">测试结果：  
</font>![](https://cdn.nlark.com/yuque/0/2025/png/38820023/1742800771605-2d0bbe86-f25d-4710-8dfe-2414105ce184.png)<font style="color:rgb(77, 77, 77);">  
</font><font style="color:rgb(77, 77, 77);">修改Test</font>

```java
/**
 * 目标: 使用动态代理解决实际问题，并掌握使用代理的好处。
 */
public class Test {
    public static void main(String[] args) throws Exception {
        //1、创建用户业务对象
        UserService userService = (UserService)ProxyUtil.createProxy(new UserServiceImpl());
        //2、调用用户业务的功能
        userService.login("admin", "123456");
        System.out.println("--------------------------------------");
        userService.deleteUsers();
        System.out.println("--------------------------------------");
        String[] names = userService.selectUsers();
        System.out.println("查询到的用户是：" + Arrays.toString(names));
        System.out.println("--------------------------------------");

    }
}
```

<font style="color:rgb(77, 77, 77);">测试结果：  
</font>![](https://cdn.nlark.com/yuque/0/2025/png/38820023/1742800772239-8dd3b54f-cee4-46e4-93d9-9d16cea244f7.png)<font style="color:rgb(77, 77, 77);">  
</font><font style="color:rgb(77, 77, 77);">执行逻辑：  
</font>![](https://cdn.nlark.com/yuque/0/2025/png/38820023/1742800772756-4f30859f-580f-4acf-b989-138224619b86.png)

